<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotatable Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            perspective: 1000px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            overflow: hidden;
        }

        .cube-container {
            width: 200px;
            height: 200px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s ease;
        }

        .cube-face {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            box-shadow: inset 0 0 20px rgba(255,255,255,0.1);
        }

        .front {
            background: rgba(255, 99, 132, 0.8);
            transform: translateZ(100px);
        }

        .back {
            background: rgba(54, 162, 235, 0.8);
            transform: translateZ(-100px) rotateY(180deg);
        }

        .right {
            background: rgba(255, 205, 86, 0.8);
            transform: rotateY(90deg) translateZ(100px);
        }

        .left {
            background: rgba(75, 192, 192, 0.8);
            transform: rotateY(-90deg) translateZ(100px);
        }

        .top {
            background: rgba(153, 102, 255, 0.8);
            transform: rotateX(90deg) translateZ(100px);
        }

        .bottom {
            background: rgba(255, 159, 64, 0.8);
            transform: rotateX(-90deg) translateZ(100px);
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: default;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .control-button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .control-button:hover {
            background: #45a049;
        }

        .manual-control {
            margin-top: 20px;
            text-align: center;
        }

        .rotation-slider {
            width: 200px;
            margin: 10px;
        }

        .title {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .vertex {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #e74c3c;
            border: 1px solid #fff;
            border-radius: 50%;
            cursor: grab;
            z-index: 100;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.6);
            transition: all 0.1s ease;
        }

        .vertex:hover {
            background: #f39c12;
            transform: scale(1.3);
            box-shadow: 0 0 12px rgba(243, 156, 18, 0.8);
        }

        .vertex.dragging {
            background: #f39c12;
            transform: scale(1.5);
            cursor: grabbing;
            z-index: 200;
        }

        .cube-face.deformable {
            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
        }
    </style>
</head>
<body>
    <div class="title">3D Rotatable Cube</div>
    
    <div class="controls">
        <h3>Controls</h3>
        <button class="control-button" onclick="resetRotation()">Reset</button>
        
        <div class="manual-control">
            <label>X Rotation:</label><br>
            <input type="range" class="rotation-slider" id="rotateX" min="0" max="360" value="0" oninput="manualRotate()">
            <br>
            <label>Y Rotation:</label><br>
            <input type="range" class="rotation-slider" id="rotateY" min="0" max="360" value="0" oninput="manualRotate()">
        </div>
    </div>

    <div class="cube-container" id="cube">
        <div class="cube-face front deformable" id="frontFace">
            FRONT
            <div class="vertex" data-face="front" data-index="0"></div>
            <div class="vertex" data-face="front" data-index="1"></div>
            <div class="vertex" data-face="front" data-index="2"></div>
            <div class="vertex" data-face="front" data-index="3"></div>
        </div>
        <div class="cube-face back deformable" id="backFace">
            BACK
            <div class="vertex" data-face="back" data-index="0"></div>
            <div class="vertex" data-face="back" data-index="1"></div>
            <div class="vertex" data-face="back" data-index="2"></div>
            <div class="vertex" data-face="back" data-index="3"></div>
        </div>
        <div class="cube-face right deformable" id="rightFace">
            RIGHT
            <div class="vertex" data-face="right" data-index="0"></div>
            <div class="vertex" data-face="right" data-index="1"></div>
            <div class="vertex" data-face="right" data-index="2"></div>
            <div class="vertex" data-face="right" data-index="3"></div>
        </div>
        <div class="cube-face left deformable" id="leftFace">
            LEFT
            <div class="vertex" data-face="left" data-index="0"></div>
            <div class="vertex" data-face="left" data-index="1"></div>
            <div class="vertex" data-face="left" data-index="2"></div>
            <div class="vertex" data-face="left" data-index="3"></div>
        </div>
        <div class="cube-face top deformable" id="topFace">
            TOP
            <div class="vertex" data-face="top" data-index="0"></div>
            <div class="vertex" data-face="top" data-index="1"></div>
            <div class="vertex" data-face="top" data-index="2"></div>
            <div class="vertex" data-face="top" data-index="3"></div>
        </div>
        <div class="cube-face bottom deformable" id="bottomFace">
            BOTTOM
            <div class="vertex" data-face="bottom" data-index="0"></div>
            <div class="vertex" data-face="bottom" data-index="1"></div>
            <div class="vertex" data-face="bottom" data-index="2"></div>
            <div class="vertex" data-face="bottom" data-index="3"></div>
        </div>
    </div>

    <script>
        const cube = document.getElementById('cube');
        let isDragging = false;
        let isVertexDragging = false;
        let dragVertex = null;
        let dragFace = null;
        let previousMousePosition = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };

        // 8 unique vertices for the cube (3D coordinates)
        const initialCubeVertices = [
            { x: -80, y: -80, z: 80 },  // 0: front-top-left
            { x: 80, y: -80, z: 80 },   // 1: front-top-right
            { x: 80, y: 80, z: 80 },    // 2: front-bottom-right
            { x: -80, y: 80, z: 80 },   // 3: front-bottom-left
            { x: -80, y: -80, z: -80 }, // 4: back-top-left
            { x: 80, y: -80, z: -80 },  // 5: back-top-right
            { x: 80, y: 80, z: -80 },   // 6: back-bottom-right
            { x: -80, y: 80, z: -80 }   // 7: back-bottom-left
        ];

        // Current positions of the 8 cube vertices
        let cubeVertices = [...initialCubeVertices.map(v => ({...v}))];

        // Define which cube vertices each face uses
        const faceVertexIndices = {
            front: [0, 1, 2, 3],
            back: [5, 4, 7, 6],   // back face vertices in correct order
            right: [1, 5, 6, 2],  // right face vertices
            left: [4, 0, 3, 7],   // left face vertices
            top: [4, 5, 1, 0],    // top face vertices
            bottom: [3, 2, 6, 7]  // bottom face vertices
        };

        // Map each visual vertex to its corresponding cube vertex
        const vertexMapping = {};
        Object.keys(faceVertexIndices).forEach(face => {
            vertexMapping[face] = {};
            faceVertexIndices[face].forEach((cubeVertexIndex, faceVertexIndex) => {
                vertexMapping[face][faceVertexIndex] = cubeVertexIndex;
            });
        });

        // Since vertices are now children of faces, they inherit the face transform
        // We just need to position them relative to their parent face

        function initializeVertices() {
            const vertices = document.querySelectorAll('.vertex');
            vertices.forEach((vertex) => {
                const face = vertex.dataset.face;
                const index = parseInt(vertex.dataset.index);
                updateVertexPosition(vertex, face, index);
                vertex.addEventListener('mousedown', startVertexDrag);
            });
            updateAllFaces();
        }

        function updateVertexPosition(vertex, face, index) {
            const cubeVertexIndex = vertexMapping[face][index];
            const cubeVertex = cubeVertices[cubeVertexIndex];
            
            // Project 3D vertex to 2D face coordinates
            let pos2D = project3DToFace(cubeVertex, face);
            
            // Position relative to the face (which is 200x200px)
            vertex.style.left = `${100 + pos2D.x}px`;
            vertex.style.top = `${100 + pos2D.y}px`;
            vertex.style.transform = `translateZ(2px)`; // Just slightly in front of the face
        }

        function project3DToFace(vertex3D, face) {
            // Project 3D coordinates to 2D face coordinates
            switch(face) {
                case 'front':
                case 'back':
                    return { x: vertex3D.x, y: vertex3D.y };
                case 'right':
                case 'left':
                    return { x: vertex3D.z * (face === 'right' ? -1 : 1), y: vertex3D.y };
                case 'top':
                case 'bottom':
                    return { x: vertex3D.x, y: vertex3D.z * (face === 'top' ? -1 : 1) };
            }
        }

        function updateFace(face) {
            const faceElement = document.getElementById(`${face}Face`);
            const faceVertices = faceVertexIndices[face];
            
            // Get 2D positions for this face
            const positions = faceVertices.map(cubeVertexIndex => {
                const cubeVertex = cubeVertices[cubeVertexIndex];
                return project3DToFace(cubeVertex, face);
            });
            
            const points = positions.map(pos => {
                const x = ((pos.x + 100) / 200) * 100; // Adjust for larger range
                const y = ((pos.y + 100) / 200) * 100;
                return `${Math.max(0, Math.min(100, x))}% ${Math.max(0, Math.min(100, y))}%`;
            });
            faceElement.style.clipPath = `polygon(${points.join(', ')})`;
        }

        function updateAllFaces() {
            Object.keys(faceVertexIndices).forEach(face => {
                updateFace(face);
            });
        }

        function updateAllVerticesForCubeVertex(cubeVertexIndex) {
            // Update all visual vertices that correspond to this cube vertex
            Object.keys(faceVertexIndices).forEach(face => {
                faceVertexIndices[face].forEach((cubeIdx, faceVertexIndex) => {
                    if (cubeIdx === cubeVertexIndex) {
                        const faceElement = document.getElementById(`${face}Face`);
                        const vertex = faceElement.querySelector(`[data-index="${faceVertexIndex}"]`);
                        if (vertex) {
                            updateVertexPosition(vertex, face, faceVertexIndex);
                        }
                    }
                });
            });
        }

        function startVertexDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isVertexDragging = true;
            dragVertex = parseInt(e.target.dataset.index);
            dragFace = e.target.dataset.face;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            
            e.target.classList.add('dragging');
            document.body.style.cursor = 'grabbing';
        }

        function resetRotation() {
            cube.style.transform = 'rotateX(0deg) rotateY(0deg)';
            document.getElementById('rotateX').value = 0;
            document.getElementById('rotateY').value = 0;
            currentRotation = { x: 0, y: 0 };
            
            // Reset all cube vertices
            cubeVertices = [...initialCubeVertices.map(v => ({...v}))];
            
            // Update all visual vertices
            const vertices = document.querySelectorAll('.vertex');
            vertices.forEach((vertex) => {
                const face = vertex.dataset.face;
                const index = parseInt(vertex.dataset.index);
                updateVertexPosition(vertex, face, index);
            });
            updateAllFaces();
        }

        function manualRotate() {
            const rotateX = document.getElementById('rotateX').value;
            const rotateY = document.getElementById('rotateY').value;
            cube.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            currentRotation = { x: parseFloat(rotateX), y: parseFloat(rotateY) };
        }

        // Mouse interaction for manual rotation and vertex dragging
        document.addEventListener('mousedown', (e) => {
            // Don't start dragging if clicking on controls or vertices
            if (e.target.closest('.controls') || e.target.classList.contains('vertex')) {
                return;
            }
            
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            document.body.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isVertexDragging && dragVertex !== null && dragFace !== null) {
                // Vertex dragging
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const moveX = deltaX * 0.8;
                const moveY = deltaY * 0.8;
                
                // Get the cube vertex index for this face vertex
                const cubeVertexIndex = vertexMapping[dragFace][dragVertex];
                const cubeVertex = cubeVertices[cubeVertexIndex];
                
                // Apply movement based on face orientation
                switch(dragFace) {
                    case 'front':
                        cubeVertex.x += moveX;
                        cubeVertex.y += moveY;
                        break;
                    case 'back':
                        cubeVertex.x -= moveX; // Reversed for back face
                        cubeVertex.y += moveY;
                        break;
                    case 'right':
                        cubeVertex.z -= moveX; // Z movement for right face
                        cubeVertex.y += moveY;
                        break;
                    case 'left':
                        cubeVertex.z += moveX; // Z movement for left face
                        cubeVertex.y += moveY;
                        break;
                    case 'top':
                        cubeVertex.x += moveX;
                        cubeVertex.z -= moveY; // Z movement for top face
                        break;
                    case 'bottom':
                        cubeVertex.x += moveX;
                        cubeVertex.z += moveY; // Z movement for bottom face
                        break;
                }
                
                // Constrain vertices to reasonable bounds
                cubeVertex.x = Math.max(-120, Math.min(120, cubeVertex.x));
                cubeVertex.y = Math.max(-120, Math.min(120, cubeVertex.y));
                cubeVertex.z = Math.max(-120, Math.min(120, cubeVertex.z));
                
                // Update all visual vertices that correspond to this cube vertex
                updateAllVerticesForCubeVertex(cubeVertexIndex);
                
                // Update all faces that use this vertex
                Object.keys(faceVertexIndices).forEach(face => {
                    if (faceVertexIndices[face].includes(cubeVertexIndex)) {
                        updateFace(face);
                    }
                });
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            } else if (isDragging) {
                // Cube rotation
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                currentRotation.y += deltaX * 0.5;
                currentRotation.x -= deltaY * 0.5;
                
                cube.style.transform = `rotateX(${currentRotation.x}deg) rotateY(${currentRotation.y}deg)`;
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
                
                // Update sliders
                document.getElementById('rotateX').value = Math.abs(currentRotation.x % 360);
                document.getElementById('rotateY').value = Math.abs(currentRotation.y % 360);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                document.body.style.cursor = 'default';
            }
            if (isVertexDragging) {
                isVertexDragging = false;
                dragVertex = null;
                dragFace = null;
                document.body.style.cursor = 'default';
                const vertices = document.querySelectorAll('.vertex');
                vertices.forEach(v => v.classList.remove('dragging'));
            }
        });

        // Touch support for mobile
        document.addEventListener('touchstart', (e) => {
            // Don't start dragging if touching controls
            if (e.target.closest('.controls')) {
                return;
            }
            
            isDragging = true;
            const touch = e.touches[0];
            previousMousePosition = { x: touch.clientX, y: touch.clientY };
            document.body.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('touchmove', (e) => {
            if (isDragging) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - previousMousePosition.x;
                const deltaY = touch.clientY - previousMousePosition.y;
                
                currentRotation.y += deltaX * 0.5;
                currentRotation.x -= deltaY * 0.5;
                
                cube.style.transform = `rotateX(${currentRotation.x}deg) rotateY(${currentRotation.y}deg)`;
                
                previousMousePosition = { x: touch.clientX, y: touch.clientY };
                
                document.getElementById('rotateX').value = Math.abs(currentRotation.x % 360);
                document.getElementById('rotateY').value = Math.abs(currentRotation.y % 360);
                
                e.preventDefault();
            }
        });

        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                document.body.style.cursor = 'default';
            }
            if (isVertexDragging) {
                isVertexDragging = false;
                dragVertex = null;
                dragFace = null;
                document.body.style.cursor = 'default';
                const vertices = document.querySelectorAll('.vertex');
                vertices.forEach(v => v.classList.remove('dragging'));
            }
        });

        // Initialize vertices when page loads
        window.addEventListener('load', initializeVertices);
    </script>
</body>
</html>

